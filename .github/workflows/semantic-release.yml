name: Frontend Release

on:
  push:
    branches: [main]

jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Install deps
        run: npm i -f

      - name: Run Semantic Release
        id: semantic
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: npx semantic-release

      - name: Generate PR-based Release Notes
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get current and previous tags
          git fetch --tags
          CURRENT_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

          if [ -z "$CURRENT_TAG" ]; then
            echo "No tags found, skipping release notes generation"
            exit 0
          fi

          PREVIOUS_TAG=$(git describe --tags --abbrev=0 "${CURRENT_TAG}^" 2>/dev/null || echo "")
          VERSION="${CURRENT_TAG#v}"
          DATE=$(date +"%B %d, %Y")

          echo "Current tag: $CURRENT_TAG"
          echo "Previous tag: $PREVIOUS_TAG"

          # Get commits between tags
          if [ -n "$PREVIOUS_TAG" ]; then
            COMMIT_RANGE="${PREVIOUS_TAG}..${CURRENT_TAG}"
          else
            COMMIT_RANGE="${CURRENT_TAG}"
          fi

          echo "Commit range: $COMMIT_RANGE"

          # Get commit SHAs in the range
          COMMIT_SHAS=$(git log ${COMMIT_RANGE} --pretty=format:"%H" 2>/dev/null | head -50)

          # Find PRs associated with these commits
          PR_NUMBERS=""
          for SHA in $COMMIT_SHAS; do
            # Use GitHub API to find PR for this commit
            PR_NUM=$(gh api "/repos/${{ github.repository }}/commits/${SHA}/pulls" --jq '.[0].number' 2>/dev/null || echo "")
            if [ -n "$PR_NUM" ] && [ "$PR_NUM" != "null" ]; then
              PR_NUMBERS="$PR_NUMBERS $PR_NUM"
            fi
          done

          # Remove duplicates
          PR_NUMBERS=$(echo "$PR_NUMBERS" | tr ' ' '\n' | sort -u | grep -v '^$')

          echo "Found PRs: $PR_NUMBERS"

          # Backup existing release notes if they exist
          if [ -f RELEASE_NOTES.md ]; then
            cp RELEASE_NOTES.md RELEASE_NOTES_BACKUP.md
          fi

          # Initialize NEW release section in a temporary file
          cat > NEW_RELEASE.md << 'HEADER'
          # ðŸš€ Release Notes
          HEADER

          # Add version and date
          echo "" >> NEW_RELEASE.md
          echo "## ${CURRENT_TAG}" >> NEW_RELEASE.md
          echo "" >> NEW_RELEASE.md
          echo "**Release Date:** ${DATE}" >> NEW_RELEASE.md
          echo "" >> NEW_RELEASE.md
          echo "---" >> NEW_RELEASE.md
          echo "" >> NEW_RELEASE.md

          # Process PRs
          FEATURES=""
          FIXES=""
          OTHER=""

          for PR_NUM in $PR_NUMBERS; do
            echo "Fetching PR #${PR_NUM}..."
            
            PR_DATA=$(gh pr view "$PR_NUM" --json title,body 2>/dev/null || echo "")
            
            if [ -z "$PR_DATA" ]; then
              continue
            fi
            
            PR_TITLE=$(echo "$PR_DATA" | jq -r '.title // "No title"')
            # Extract PR body with safe truncation: first try to split on horizontal rules,
            # then fall back to character limit with safe word-boundary truncation
            PR_BODY=$(echo "$PR_DATA" | jq -r '.body // ""' | \
              awk '/^[-]{3,}$|^[*]{3,}$|^[_]{3,}$/ { exit } { print }' | \
              awk -v maxlen=2000 'BEGIN { accum="" }
              {
                line_len = length($0)
                newline_len = (accum != "" ? 1 : 0)
                total = length(accum) + newline_len + line_len
                if (total <= maxlen) {
                  accum = accum (accum != "" ? "\n" : "") $0
                } else {
                  # Need to truncate - find safe break point at word boundary
                  remaining = maxlen - length(accum) - newline_len
                  if (remaining > 20) {
                    # Extract substring and find last whitespace
                    line = substr($0, 1, remaining)
                    if (match(line, /.*[[:space:]]/)) {
                      accum = accum "\n" substr(line, 1, RLENGTH) "..."
                    } else {
                      accum = accum "\n" line "..."
                    }
                  } else {
                    # Very little space left, trim accum to last whitespace
                    if (match(accum, /.*[[:space:]]/)) {
                      accum = substr(accum, 1, RLENGTH) "..."
                    } else if (length(accum) > 0) {
                      accum = accum "..."
                    }
                  }
                  exit
                }
              }
              END { print accum }')
            
            # Create entry
            ENTRY="### PR #${PR_NUM}: ${PR_TITLE}

          ${PR_BODY}

          ---

          "
            
            # Categorize based on PR title
            if echo "$PR_TITLE" | grep -qiE "^feat|feature|add|new"; then
              FEATURES="${FEATURES}${ENTRY}"
            elif echo "$PR_TITLE" | grep -qiE "^fix|bug|resolve|hotfix"; then
              FIXES="${FIXES}${ENTRY}"
            else
              OTHER="${OTHER}${ENTRY}"
            fi
          done

          # Write sections to NEW_RELEASE.md
          if [ -n "$FEATURES" ]; then
            echo "## âœ¨ New Features" >> NEW_RELEASE.md
            echo "" >> NEW_RELEASE.md
            echo "$FEATURES" >> NEW_RELEASE.md
          fi

          if [ -n "$FIXES" ]; then
            echo "## ðŸ› Bug Fixes" >> NEW_RELEASE.md
            echo "" >> NEW_RELEASE.md
            echo "$FIXES" >> NEW_RELEASE.md
          fi

          if [ -n "$OTHER" ]; then
            echo "## ðŸ“¦ Other Changes" >> NEW_RELEASE.md
            echo "" >> NEW_RELEASE.md
            echo "$OTHER" >> NEW_RELEASE.md
          fi

          # If no PRs found, add a note
          if [ -z "$FEATURES" ] && [ -z "$FIXES" ] && [ -z "$OTHER" ]; then
            echo "No PR descriptions available for this release." >> NEW_RELEASE.md
            echo "" >> NEW_RELEASE.md
            echo "See [CHANGELOG.md](./CHANGELOG.md) for commit details." >> NEW_RELEASE.md
            echo "" >> NEW_RELEASE.md
          fi

          # Add separator before old releases
          echo "" >> NEW_RELEASE.md
          echo "---" >> NEW_RELEASE.md
          echo "" >> NEW_RELEASE.md

          # Merge with existing release notes (if they exist)
          if [ -f RELEASE_NOTES_BACKUP.md ]; then
            # Skip the header from old file and append the rest
            tail -n +2 RELEASE_NOTES_BACKUP.md >> NEW_RELEASE.md
            rm RELEASE_NOTES_BACKUP.md
          else
            # First release, add footer
            echo "ðŸ“‹ For detailed commit history, see [CHANGELOG.md](./CHANGELOG.md)" >> NEW_RELEASE.md
            echo "" >> NEW_RELEASE.md
            echo "---" >> NEW_RELEASE.md
            echo "" >> NEW_RELEASE.md
            echo "*Auto-generated from PR descriptions.*" >> NEW_RELEASE.md
          fi

          # Replace the old file with the new merged version
          mv NEW_RELEASE.md RELEASE_NOTES.md

          echo "âœ… RELEASE_NOTES.md generated:"
          cat RELEASE_NOTES.md

      - name: Commit and Push Release Notes
        run: |
          if [ -f RELEASE_NOTES.md ]; then
            git config --local user.email "github-actions[bot]@users.noreply.github.com"
            git config --local user.name "github-actions[bot]"
            git add RELEASE_NOTES.md
            git diff --staged --quiet || git commit -m "docs: update RELEASE_NOTES.md [skip ci]"
            git push origin main || echo "Nothing to push"
          fi
